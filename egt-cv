#!/usr/bin/python
import cliapp
import egtlib
import yaml
import logging
import sys
import os
import shutil
import jinja2
import subprocess
import datetime

VERSION="0.1"

class CV(object):
    def __init__(self, dirname):
        self.dirname = dirname
        self.personal = {}
        self.shortbio = []
        self.languages = []
        self.skills = []
        self.tags = {}
        self.logs = {}

    def load(self):
        # Load base info from yaml files
        for fn in sorted(os.listdir(self.dirname)):
            if not fn.endswith(".yaml"): continue
            pathname = os.path.join(self.dirname, fn)
            with open(pathname) as fd:
                info = yaml.load(fd)
                self.acquire_structured(info)

        # Load historical info from egt, based on tags set in yaml files
        for k, v in self.tags.iteritems():
            if isinstance(v, basestring):
                tags = frozenset((v,))
            else:
                tags = frozenset(v)
            egt = egtlib.Egt(tags=tags, archived=True)
            logs = []
            for p in egt.projects.itervalues():
                # Get the period
                since, until = p.formal_period
                if isinstance(until, datetime.date) and until > datetime.date.today() - datetime.timedelta(days=7):
                    until = None
                logs.append({
                    "name": p.name,
                    "title": p.meta.get("title", p.name.capitalize()),
                    "employer": p.meta.get("employer", None),
                    "description": p.meta.get("description", None),
                    "period": { "since": since, "until": until },
                })
            if logs:
                self.logs.setdefault(k, []).extend(logs)

    def acquire_structured(self, info):
        """
        Acquire general info from a data structure
        """
        i = info.get("personal", None)
        if i is not None:
            for k, v in i.iteritems():
                if k == "telephone":
                    tels = self.personal.setdefault(k, [])
                    for t in v:
                        for tk, tv in t.iteritems():
                            tels.append({
                                "name": tk,
                                "value": tv,
                            })
                elif k in ("email", "homepage"):
                    # Coerce to list
                    if isinstance(v, basestring):
                        self.personal[k] = [v]
                    else:
                        self.personal[k] = v
                else:
                    self.personal[k] = v

        i = info.get("shortbio", None)
        if i is not None:
            if isinstance(i, basestring):
                self.shortbio.append(i)
            else:
                self.shortbio.extend(i)

        i = info.get("languages", None)
        if i is not None:
            for lang in i:
                for k, v in lang.iteritems():
                    self.languages.append({
                        "name": k,
                        "skill": v,
                    })

        i = info.get("skills", None)
        if i is not None:
            if isinstance(i, basestring):
                self.skills.append(i)
            else:
                self.skills.extend(i)

        i = info.get("tags", {})
        for k, v in i.iteritems():
            self.tags[k] = v

    def template_context(self):
        """
        Return a dict with all the arguments to pass to the template renderer
        """
        return {
            "dirname": self.dirname,
            "personal": self.personal,
            "shortbio": self.shortbio,
            "languages": self.languages,
            "skills": self.skills,
            "lastedit": datetime.date.today(),
            "logs": self.logs,
        }

    def dump(self, out=sys.stdout):
        """
        Dump all info we have to the given file descriptor
        """
        yaml.dump(self.template_context(), out)

    def translatable_strings(self):
        """
        Generate all the translatable strings found in the data
        """
        for k in ("nationality", "notes"):
            s = self.personal.get(k, None)
            if s is not None:
                yield s

        tel = self.personal.get("telephone", None)
        if tel is not None:
            for t in tel:
                yield t["name"]

        for s in self.shortbio:
            yield s

        for l in self.languages:
            yield l["name"]
            yield l["skill"]

        for s in self.skills:
            yield s

    def extract_strings(self):
        from babel.messages import Catalog
        c = Catalog()

        # Instantiate jinja2 machinery to get string extraction
        jinja_env = jinja2.Environment(extensions=['jinja2.ext.i18n'])

        # Add our strings
        for s in self.translatable_strings():
            c.add(s)

        # Add strings from jinja2 templates
        tpldir = os.path.join(self.dirname, "templates")
        for fn in os.listdir(tpldir):
            if not fn.endswith(".html"): continue
            pathname = os.path.join(tpldir, fn)
            with open(pathname) as fd:
                for lineno, func, msg in jinja_env.extract_translations(fd.read()):
                    c.add(msg, locations=((pathname, lineno),))

        return c

    def list_languages(self):
        """
        Get the list of available output languages
        """
        localedir = os.path.join(self.dirname, "locale")
        for lang in os.listdir(localedir):
            if lang[0] == ".": continue
            dn = os.path.join(localedir, lang)
            if not os.path.isdir(dn): continue
            yield lang, dn

    def update_catalogs(self):
        from babel.messages.pofile import read_po, write_po

        new_catalog = self.extract_strings()

        # Scan locale dirs
        for lang, langdir in self.list_languages():
            # If a locale dir exists, make sure it contains what is needed
            msgdir = os.path.join(langdir, "LC_MESSAGES")
            if not os.path.isdir(msgdir):
                os.mkdir(msgdir)
            msgfile = os.path.join(msgdir, "cv.po")
            # Read the existing potfile if it exists
            if os.path.isfile(msgfile):
                with open(msgfile) as fd:
                    cat = read_po(fd)
                    cat.update(new_catalog)
            else:
                cat = new_catalog

            # Write updated catalogs
            with open(msgfile, "w") as fd:
                write_po(fd, cat)
                print lang

    def render(self, outdir, locales):
        """
        Render the curriculum, writing results to the given output directory
        """
        from babel.support import Translations
        # Reset the output directory
        if os.path.exists(outdir):
            shutil.rmtree(outdir)
        os.mkdir(outdir)

        # Get translations
        translations = Translations.load(
            os.path.join(self.dirname, "locale"),
            locales,
            "cv")

        # Instantiate jinja2 template machinery
        tpldir = os.path.join(self.dirname, "templates")
        jinja_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(tpldir),
            extensions=['jinja2.ext.i18n'])
        jinja_env.install_gettext_translations(translations, True)

        jinja_context = self.template_context()

        # Copy everything except .html files
        for fn in os.listdir(tpldir):
            if fn.startswith("."): continue
            if fn.endswith(".html"):
                # Render .html files with jinja2
                tpl = jinja_env.get_template(fn)
                rendered = tpl.render(**jinja_context)
                with open(os.path.join(outdir, fn), "w") as fd:
                    fd.write(rendered)
            else:
                # Copy all other files
                shutil.copyfile(os.path.join(tpldir, fn), os.path.join(outdir, fn))

    def render_all_languages(self):
        """
        Render the curriculum for all languages
        """
        for lang, langdir in self.list_languages():
            # Ensure translations are up to date
            subprocess.check_call(["msgfmt", "-c", "-f", "-o",
                                   os.path.join(langdir, "LC_MESSAGES/cv.mo"),
                                   os.path.join(langdir, "LC_MESSAGES/cv.po")])

            outdir = os.path.join(self.dirname, "cv-" + lang)
            self.render(outdir, (lang,))


class EgtCVApp(cliapp.Application):
    def __init__(self):
        super(EgtCVApp, self).__init__(
            progname="egt-cv",
            version=VERSION,
            description="Enrico's Getting Things Done",
        )

    def setup_logging(self):
        if not self.settings["log"]:
            FORMAT = "%(asctime)-15s %(levelname)s %(message)s"
            if self.settings["debug"]:
                logging.basicConfig(level=logging.DEBUG, stream=sys.stderr, format=FORMAT)
            elif self.settings["verbose"]:
                logging.basicConfig(level=logging.INFO, stream=sys.stderr, format=FORMAT)
            else:
                logging.basicConfig(level=logging.WARN, stream=sys.stderr, format=FORMAT)
        else:
            super(EgtCVApp, self).setup_logging()

    def add_settings(self):
        self.settings.boolean(['verbose', 'v'], "verbose output")
        self.settings.boolean(['debug'], "debug output")

    def cmd_dump(self, args):
        """
        Dump all cv information to standard output
        """
        cv = CV(args[0])
        cv.load()
        cv.dump()

    def cmd_update_catalogs(self, args):
        """
        Update the catalogs of translatable strings.

        In order to start a translation, just run:
          mkdir $cvdir/locale/$LANG
        """
        cv = CV(args[0])
        cv.load()
        cv.update_catalogs()

    def cmd_render(self, args):
        """
        Render the CV for all configured languages
        """
        cv = CV(args[0])
        cv.load()
        cv.render_all_languages()

if __name__ == '__main__':
    EgtCVApp().run()
